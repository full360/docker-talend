# docker-ci.mk
#
# Copyright (c) 2017, Full 360 Inc
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the organization nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL HERBERT G. FISCHER BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Get the Full 360 Opinionated Docker Makefile
DOCKERMK := $(shell if [ ! -e docker-ci.mk ]; then \
                    wget -N -q https://raw.githubusercontent.com/full360/docker-ci/master/docker-ci.mk; fi)
include docker-ci.mk


# consul-template -template "$$<:$$@" --once

##########################################################################################
# Definitions
##########################################################################################

# This definition extracts the contexts that are available in the talend job and
# uses consul-template to build the ECS and NOMAD Templates
# DEPLOYMENT_ENVIRONMENT=$(basename $(notdir $E)) ENVMAP_DIR=$(dir $E) \
#  CONTEXT=$C TALENDIMAGE=$(DOCKER_CI_REPO)$(call group,$(call imagebase_from_dockerfile,$(dir $T)../../Dockerfile)):latest \

define SCHEDULERCONTEXTRULE
# List of Scheduler JOBS
DEPLOY$SJOBS += deploy$(call lcase,$S)job.$(call group,$(call imagebase_from_dockerfile,$(dir $T)../../Dockerfile))-$(basename $(notdir $E)).$C
GENERATE$SJOBS += generate$(call lcase,$S)job.$(call group,$(call imagebase_from_dockerfile,$(dir $T)../../Dockerfile))-$(basename $(notdir $E)).$C

# confirm that consul-template is available
$(dir $T)%.ctmpl : consul-template

# load the environment variables from SCHEDARGS, BUILDARGS, and the envmap (using envelope)
# for the deployment environment
$(dir $T)%-$(basename $(notdir $E))-$C-generated.$(call lcase,$S): $(dir $T)%.ctmpl
	@DEPLOYMENT_ENVIRONMENT=$(basename $(notdir $E)) \
	ENVMAP_DIR=$(dir $E) \
	CONTEXT=$C \
	TALENDIMAGE=$(DOCKER_CI_REPO)$(call group,$(call imagebase_from_dockerfile,$(dir $T)../../Dockerfile)):latest  \
	$($(call imagebase_from_dockerfile,$(dir $T)../../Dockerfile).BUILDARGS) \
	envelope run consul-template -template "$$<:$$@" --once  \
	&& cat $$@

#create one target for deployment based on the schedule (aws for ecs, nomad for nomad)
ifeq (ECS,$S)
# confirm aws cli is available
$(dir $T)%-$(basename $(notdir $E))-$C-generated.$(call lcase,$S) : aws

%-$C-$(basename $(notdir $E))-deployed.json : $(dir $T)%-$(basename $(notdir $E))-$C-generated.$(call lcase,$S)
	aws ecs register-task-definition --cli-input-json file://./$$< > $$@
endif

ifeq (NOMAD,$S)
# confirm nomad is available
$(dir $T)%-$(basename $(notdir $E))-$C-generated.$(call lcase,$S) : aws

$(dir $T)%-$C-$(basename $(notdir $E))-deployed.json : $(dir $T)%-$(basename $(notdir $E))-$C-generated.$(call lcase,$S)
	nomad plan $$< > $$@
endif

generate$(call lcase,$S)job.$(call group,$(call imagebase_from_dockerfile,$(dir $T)../../Dockerfile)).$(basename $(notdir $E)).$C : $(dir $T)$(basename $(notdir $T))-$(basename $(notdir $E))-$C-generated.$(call lcase,$S)
deploy$(call lcase,$S)job.$(call group,$(call imagebase_from_dockerfile,$(dir $T)../../Dockerfile)).$(basename $(notdir $E)).$C : $(dir $T)$(basename $(notdir $T))-$(basename $(notdir $E))-$C-deployed.json
endef

# This bit bit of meta programming sets up tar.gz file of the Talend Job and makes
# available to the Dockerfile. It does this by first checking what is the Dockerfile
# that is passed in for the name of the job and the version.
#
# It then checks to see if the jobinfo.properties file generated by talend
# matches the job and version set in the Dockerfile. This allows the repo to
# contain multiple jobs and by setting the values in the Dockerfile,
# the correct job will be matched up with the correct docker image
define JOBRULE
# Get the job and version set in the Dockerfile
DOCKERTALENDJOB := $(call get_label,$2,talendjob)
DOCKERTALENDVER := $(call get_label,$2,talendver)

# load the jobInfo file as Make Variables
include $1

# Only process the jobinfo file if the job and version match in the Dockerfile
ifeq ($$(DOCKERTALENDJOB),$$(job))
ifeq ($$(DOCKERTALENDVER),$$(jobVersion))

# Directory is dependent on JobInfo file
talend/$$(job) : $1

# Dependency of tar on the job directory under talend
%/talend/$$(job).tar  : talend/$$(job)
	mkdir -p $$*/talend \
	&& tar -cvf $$@ -C talend/ $$(basename $$(notdir $$@)) \
	&& tar -rvf $$@ -C talend_overrides/ $$(basename $$(notdir $$@))

# Dependency of gz on tar
%/$$(job).tar.gz : %/$$(job).tar
	gzip -f $$^ \
  && rm -f $$(dir $$@)*.tar

# Dockerfile is dependent on tar.gz (makes sure that this is created before build)
$D : $(dir $2)talend/$$(job).tar.gz

else
$$(warning No Talend Job Found for $(call imagebase_from_dockerfile,$(D))!!!)
endif
endif
# Create a Make Variable that is associated with the Dockerfile image. This is
# used by the docker build process for build args
$(call imagebase_from_dockerfile,$(D)).BUILDARGS += TALENDJOB=$$(job)_$$(jobVersion) \
             TALENDPREFIX=$$(job) \
						 TALENDJOBVER=$$(jobVersion) \
						 TALENDJOBVERUNDERSCORE=$$(subst .,_,$$(jobVersion)) \
						 TALENDPROJECT=$$(call lcase,$$(project)) \
						 TALENDPREFIXLCASE=$$(call lcase,$$(job))
endef

# find all the talend contexts available in the jobs
CONTEXTS := $(sort $(basename $(notdir $(shell find * -mindepth 1 -type f -path '*/contexts/*' -name *.properties))))

# find the consul templates for ecs
ECSJOBTEMPLATES := $(shell find * -mindepth 1 -type f -path '*/scheduler/ecs/*' -name *.ctmpl)

# find the consul templates for nomad
NOMADJOBTEMPLATES := $(shell find * -mindepth 1 -type f -path '*/scheduler/nomad/*' -name *.ctmpl)

# find the talend job information files
JOBINFOFILES := $(shell find * -mindepth 1 -type f -path 'talend/*' -name jobInfo.properties)

# find the envmaps
ENVMAPS := $(shell find * -mindepth 1 -type f -path '*/envmaps/*' -name *.envmap)

# Generate the talend tars to load into the image
$(foreach J,$(JOBINFOFILES),$(foreach D, $(DOCKERFILES),$(eval $(call JOBRULE,$J,$D))))

# for each scheduler, envmap and context create scheduler definitions using templates
ifeq (,$(ENVMAPS))
# Generate the ecs job template targets based on the contexts available
$(foreach S,NOMAD ECS,$(foreach D,$(DOCKERDIRS),$(foreach E,default,$(foreach T,$(filter $D/%, $($SJOBTEMPLATES)),$(foreach C,$(CONTEXTS),$(eval $(SCHEDULERCONTEXTRULE)))))))
else
$(foreach S,NOMAD ECS,$(foreach D,$(DOCKERDIRS),$(foreach E,$(filter $D/%, $(ENVMAPS)),$(foreach T,$(filter $D/%, $($SJOBTEMPLATES)),$(foreach C,$(CONTEXTS),$(eval	 $(SCHEDULERCONTEXTRULE)))))))
endif

# export some items for later availability
export REGISTRY_REGION
export KMSKEYPREFIX

# Set default root
ifndef ETL_ROOT
ETL_ROOT=/etl
endif


BUILDARGS+=ETL_ROOT=$(ETL_ROOT)

.PHONY: showtalendjobs
showtalendjobs:
	$(foreach I, $(JOBINFOFILES),  $(info | $(dir $(I)))      )
	@exit 0

.PHONY: showecs
showecs:
	$(foreach I, $(DEPLOYECSJOBS),  $(info | $(I))     )
	@exit 0

.PHONY: shownomad
shownomad:
	$(foreach I, $(DEPLOYNOMADJOBS),  $(info | $(I))     )
	@exit 0

deployecsjob.all: $(DEPLOYECSJOBS)

generateecsjob.all: $(GENERATEECSJOBS)

deploynomadjob.all: $(DEPLOYNOMADJOBS)

generatenomadjob.all: $(GENERATENOMADJOBS)

mkhelp : mktalendhelp

.PHONY: mktalendhelp
mktalendhelp:
	$(info Available talend targets:             )
	$(info | showtalendjobs                      )
	$(info ECS                                   )
	$(info | showecs                             )
	$(info | deployecsjob.all                    )
	$(info | deployecsjob.ENVMAP.CONTEXT                )
	$(info | generateecsjob.all                  )
	$(info | generateecsjob.ENVMAP.CONTEXT              )
	$(info NOMAD                                 )
	$(info | shownomad                           )
	$(info | deploynomadjob.all                  )
	$(info | deploynomadjob.ENVMAP.CONTEXT              )
	$(info | generatnomadjob.all                 )
	$(info | generatenomadjob.ENVMAP.CONTEXT            )
	@exit 0

clean : talendclean

talendclean:
	@find . -type f -name *.tar.gz -exec rm {} \; &&\
	find . -type f -name *.tgz -exec rm {} \; &&\
	find . -type f -name *-generated.nomad -exec rm {} \; &&\
	find . -type f -name *-generated.ecs -exec rm {} \; &&\
	find . -type f -name *-generated.json -exec rm {} \;
