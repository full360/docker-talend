#!/bin/bash
export CONTEXT=$1

function run_hook {
	if [ -e "$1" ]
	then
		echo "running hook script $1"
		envelope run $1
		echo "finshed hook script $1"
	fi
}

function runit() {
	# this runs for ever until interruped, or the block semaphone is created
while true :
do
	run_hook ${TALENDROOTDIR}/bin/pre_job_hook.sh;
	$TALENDCOMMAND --context=$1 "$@";
	run_hook ${TALENDROOTDIR}/bin/post_job_hook.sh

	echo "checking if there is a block"
	if [ -e "${TALENDROOTDIR}/block" ]
	then
		echo "breaking due to presence of ${TALENDROOTDIR}/block"
		break
	fi
done
exit 1
}

export -f run_hook

# Run init hook
run_hook ${TALENDROOTDIR}/bin/init_hook.sh

# set TALENDCOMMAND after any pre-job hooks
export TALENDCOMMAND="${TALEND_EXECUTABLE} ${JAVA_ARGS} ${JAVA_CP} ${TALENDJOBCLASS}"
printf "project:      %s\n\
job:          %s\n\
prefix:       %s\n\
prefixlcase:  %s\n\
job version:  %s\n\
job _version: %s\n\
job dir     : %s\n\
context dir : %s\n\
job class   : %s\n\
jar name    : %s\n\
" $TALENDPROJECT $TALENDJOB $TALENDPREFIX $TALENDPREFIXLCASE $TALENDJOBVER \
  $TALENDJOBVERUNDERSCORE $TALENDJOBDIR $TALENDJOBCONTEXTSDIR $TALENDJOBCLASS \
  $TALENDJARNAME;\
echo "java args     : $JAVA_ARGS";\
echo "command       : $TALENDCOMMAND --context=$1 \"$@\""

# this traps a interrupt or termination so we can gracefully exit
trap 'touch ${TALENDROOTDIR}/block' TERM INT EXIT

# run the pre, main and post job hooks but wait for completion
# this is run as function so that the sgnals can be trapped across the
# hooks and main program
runit $CONTEXT &
PID=$!
wait $PID

rm -f ${TALENDJOBDIR}/block
EXIT_STATUS=$?
